package com.itkluo.demo.usb.wdreader.readerlib;import android.content.Context;import android.hardware.usb.UsbDevice;import android.hardware.usb.UsbDeviceConnection;import android.hardware.usb.UsbEndpoint;import android.hardware.usb.UsbInterface;import android.hardware.usb.UsbManager;import android.util.Log;import com.ivsign.android.IDCReader.IDCReaderSDK;import java.util.Arrays;import java.util.HashMap;import java.util.Iterator;public class HIDReader {    private static final String TAG = "wdReader";    private static final String DEBUGTAG = "HIDReader";    //此变量代表读社保卡的NAD号    private byte NAD_READSBK = (byte) 0x15;    private static final byte NAD_FEIJIE = (byte) 0x15;    private static final byte NAD_PSAM1 = (byte) 0x16;    /**     * //算法标识     * #define  DES_ALG            1          //DES算法     * #define  SSFF33_ALG         2          //SSF33算法     * #define  SM4_ALG            3          //SM4算法     * <p>     * //规范版本号     * #define  CARD_VERR          -1         //版本号错误     * #define  CARD_V1            1          //v1.0     * #define  CARD_V2            2          //v1.2     * #define  CARD_V3            3          //v1.3     */    public static final int DES_ALG = 1;//DES算法    public static final int SSFF33_ALG = 2;//SSF33算法    public static final int SM4_ALG = 3;//SM4算法    public static final int CARD_VERR = -1;    public static final int CARD_V1 = 1;    public static final int CARD_V2 = 2;    public static final int CARD_V3 = 3;    private UsbManager mmanager;    private UsbDevice mUsbDevice;    private UsbInterface mInterface;    private UsbDeviceConnection mDeviceConnection;    private UsbEndpoint mepOut;    private UsbEndpoint mepIn;    byte mnad;    int mInMaxPacketSize;    int mOutMaxPacketSize;    int mReaderType = 0;    boolean isopen = false;    public boolean getopenstate() {        return isopen;    }    public void setMmanager(UsbManager mmanager) {        this.mmanager = mmanager;    }    public HashMap<String, UsbDevice> ListHIDReader(UsbManager managerpara) {        HashMap<String, UsbDevice> WddeviceList = new HashMap<String, UsbDevice>();        if (managerpara == null) {            DisplayLog("UsbManager is null");            LogDriveUtil.d(TAG, "usbmanager is null");            return null;        }        mmanager = managerpara;        HashMap<String, UsbDevice> deviceList = mmanager.getDeviceList();        Iterator<UsbDevice> deviceIterator = deviceList.values().iterator();        while (deviceIterator.hasNext()) {            UsbDevice device = deviceIterator.next();            if (device.getVendorId() == 5692) {                WddeviceList.put(device.getDeviceName(), device);                String devname = device.getDeviceName();                DisplayLog(devname);                LogDriveUtil.d(TAG, devname);            }        }        return WddeviceList;    }    public int OpenHIDReader(UsbDevice UsbDevicepara) {        int interfacecount = 0;        if (UsbDevicepara == null) {            return -1;        }        mUsbDevice = UsbDevicepara;        interfacecount = mUsbDevice.getInterfaceCount();        if (interfacecount < 1) {            DisplayLog("can not find Interface");            LogDriveUtil.d(TAG, "can not find Interface");            return -1;        }        if (mUsbDevice.getVendorId() == 5692) {            if (mUsbDevice.getProductId() == 0x0A12 || mUsbDevice.getProductId() == 0x0A05 || mUsbDevice.getProductId() == 0x0A1F || mUsbDevice.getProductId() == 0x0A2B) {                mInterface = mUsbDevice.getInterface(1); // w7282 8298 8280            } else {                mInterface = mUsbDevice.getInterface(0);            }        } else {            mInterface = null;        }        if (mInterface == null) {            DisplayLog("Interface is NULL");            LogDriveUtil.d(TAG, "Interface is NULL");            return -1;        }        if (!mmanager.hasPermission(mUsbDevice)) {            DisplayLog("has not usb Permission");            LogDriveUtil.d(TAG, "has not usb Permission");            return -1;        }        mDeviceConnection = mmanager.openDevice(mUsbDevice);        if (mDeviceConnection == null) {            DisplayLog("open device failed");            LogDriveUtil.d(TAG, "open device failed");            return -1;        }        if (!mDeviceConnection.claimInterface(mInterface, true)) {            mDeviceConnection.close();            return -1;        }        mepOut = mInterface.getEndpoint(1);        mepIn = mInterface.getEndpoint(0);        if (mepOut == null || mepIn == null) {            mDeviceConnection.close();            DisplayLog("get endpoint failed");            LogDriveUtil.d(TAG, "get endpoint failed");            return -1;        }        mInMaxPacketSize = mepIn.getMaxPacketSize();        mOutMaxPacketSize = mepOut.getMaxPacketSize();        GetReaderType();        isopen = true;        return 0;    }    public int GetReaderType() {        mReaderType = 0;        byte[] comm = new byte[256];        int clen = 0;        byte[] resp = new byte[256];        int[] rlen = new int[1];        String strtmp = "";        int ret = 0;        //mReaderType = 4;//20191104 by:zhangkai        SetNad((byte) 0x12);        comm = HexString.hexStringToByte("0019000000");        clen = 5;        ret = HIDTransmit(comm, clen, resp, rlen);        if (0x9000 != ret) {            SetNad((byte) 0x00);            comm = HexString.hexStringToByte("0019000000");            clen = 5;            ret = HIDTransmit(comm, clen, resp, rlen);        }        if (0x9000 == ret) {            for (int i = 0; i < rlen[0]; i++) {                strtmp += (char) resp[i];            }            if (strtmp.contains("CRW-X W8298")) {                mReaderType = 4;            } else if (strtmp.contains(" CRW-X W2690")) {                mReaderType = 2;            } else if (strtmp.contains(" CRW-X W8280")) {                mReaderType = 3;            } else if (strtmp.contains(" CRW-X W8281")) {                mReaderType = 4;            } else if (strtmp.contains("CRW-X")) {                mReaderType = 1;            } else if (strtmp.contains("CRW7280")) {                mReaderType = 3;            } else if (strtmp.contains("CRW_W2386")) {                mReaderType = 0;            } else {                mReaderType = 0;            }        } else {            mReaderType = 0;        }        if (mReaderType == 2 || mReaderType == 4) {            mDeviceConnection.bulkTransfer(mepIn, resp, mInMaxPacketSize, 10);        }        //Thread.sleep(30);        return mReaderType;    }//    public int HIDTransmit(int handle, byte[] Sendbytes, int clen, byte[] Receiveytes, int[] rlen) {//        byte[] ucOutBuf = new byte[65];//        byte[] ucInBuf = new byte[65];//        int bResult;//        byte ucLenToggle = 0;//        byte ucSeqToggle = 0;//        byte ucBlockNo = 0;//        int writedlen = 0;//        int wRecvLen = 0;//        int wRetCode;//        if (mDeviceConnection == null) {//            DisplayLog("device not opened");//            return -1;//        }//        int wCmdLen = clen;//        do {//            Arrays.fill(ucOutBuf, (byte) 0x00);//            ucOutBuf[0] = mnad; ////            if (wCmdLen <= (mOutMaxPacketSize - 4)) {//                ucOutBuf[2] = (byte) wCmdLen; // Len//                ucLenToggle = 0x00;//            } else {//                ucOutBuf[2] = (byte) (mOutMaxPacketSize - 4); // Len//                ucLenToggle = 0x20;//            }//            ucOutBuf[1] = (byte) (ucLenToggle + ucSeqToggle + ucBlockNo); // PCB//            ucBlockNo++;//            if (0x00 == ucSeqToggle) {//                ucSeqToggle = 0x40;//            } else {//                ucSeqToggle = 0x00;//            }//            System.arraycopy(Sendbytes, writedlen, ucOutBuf, 3, ucOutBuf[2]);//            wCmdLen -= ucOutBuf[2];//            writedlen += ucOutBuf[2];//            DisplayLog("write data");//            DisplayLog(HexString.ByteToHexString(ucOutBuf, 65));////            bResult = mDeviceConnection.bulkTransfer(mepOut, ucOutBuf, mOutMaxPacketSize, 5000);////            if (bResult != mOutMaxPacketSize) {////                return 0x6FF0;////            }//            int tempnumber=0;//            do{//                bResult = mDeviceConnection.bulkTransfer(mepOut, ucOutBuf, mOutMaxPacketSize, 5000);//                if (bResult == mOutMaxPacketSize){//                    break;//                }//                if(bResult==-1)//                {//                    tempnumber++;//                    continue;//                }else{//                    return 0x6FF1;//                }//            } while(tempnumber<5);//        } while (wCmdLen > 0);////        ucBlockNo = 0;//        while (true) {//            ucInBuf[0] = 0x00;//            bResult = mDeviceConnection.bulkTransfer(mepIn, ucInBuf, mInMaxPacketSize, 5000);//            DisplayLog("read data");//            DisplayLog(HexString.ByteToHexString(ucInBuf, bResult));//            if (bResult != mInMaxPacketSize && bResult != mInMaxPacketSize - 1) {//                return 0x6FF2;//            }////            int tempnumber=0;////            do{////                bResult = mDeviceConnection.bulkTransfer(mepIn, ucInBuf, mInMaxPacketSize, 5000);////////                if (bResult == mInMaxPacketSize){////                    DisplayLog("read data");////                    DisplayLog(HexString.ByteToHexString(ucInBuf, bResult));////                    break;////                }////                if(bResult==-1)////                {////                    tempnumber++;////                    continue;////                }else{////                    return 0x6FF2;////                }////            }while(tempnumber<5);//            if (0xc3 == ucInBuf[1]) {//                continue;//            }//            if (0x00 == (ucInBuf[1] & 0x20)) {//                System.arraycopy(ucInBuf, 3, Receiveytes, ucBlockNo * (mInMaxPacketSize - 3), ucInBuf[2] - 2);//                wRecvLen += ucInBuf[2] - 2;//                break;//            } else {//                System.arraycopy(ucInBuf, 3, Receiveytes, ucBlockNo * (mInMaxPacketSize - 3), ucInBuf[2]);//                wRecvLen += ucInBuf[2];//            }//            ucBlockNo++;//        }//        rlen[0] = wRecvLen;//        wRetCode = (int) ((ucInBuf[ucInBuf[2] + 1] & 0xFF) << 8 | (ucInBuf[ucInBuf[2] + 2] & 0xFF));//        if (mReaderType == 2||mReaderType==4) {//            bResult = mDeviceConnection.bulkTransfer(mepIn, ucInBuf, 1, 5000);//        }////        return wRetCode;//    }    public int HIDTransmit(byte[] Sendbytes, int clen, byte[] Receiveytes, int[] rlen) {        byte[] ucOutBuf = new byte[65];        byte[] ucInBuf = new byte[65];        int bResult;        byte ucLenToggle = 0;        byte ucSeqToggle = 0;        byte ucBlockNo = 0;        int writedlen = 0;        int wRecvLen = 0;        int wRetCode;        if (mDeviceConnection == null) {            DisplayLog("device not opened");            LogDriveUtil.d(TAG, "device not opened");            return -1;        }        int wCmdLen = clen;        do {            Arrays.fill(ucOutBuf, (byte) 0x00);            ucOutBuf[0] = mnad; //            if (wCmdLen <= (mOutMaxPacketSize - 4)) {                ucOutBuf[2] = (byte) wCmdLen; // Len                ucLenToggle = 0x00;            } else {                ucOutBuf[2] = (byte) (mOutMaxPacketSize - 4); // Len                ucLenToggle = 0x20;            }            ucOutBuf[1] = (byte) (ucLenToggle + ucSeqToggle + ucBlockNo); // PCB            ucBlockNo++;            if (0x00 == ucSeqToggle) {                ucSeqToggle = 0x40;            } else {                ucSeqToggle = 0x00;            }            System.arraycopy(Sendbytes, writedlen, ucOutBuf, 3, ucOutBuf[2]);            wCmdLen -= ucOutBuf[2];            writedlen += ucOutBuf[2];            DisplayLog("write data");            DisplayLog(HexString.ByteToHexString(ucOutBuf, 65));            LogDriveUtil.d(TAG, "write data");            LogDriveUtil.d(TAG, HexString.ByteToHexString(ucOutBuf, 65));            bResult = mDeviceConnection.bulkTransfer(mepOut, ucOutBuf, mOutMaxPacketSize, 1000);            if (bResult != mOutMaxPacketSize) {                return 0x6FF1;            }        } while (wCmdLen > 0);        ucBlockNo = 0;        while (true) {            ucInBuf[0] = 0x00;            bResult = mDeviceConnection.bulkTransfer(mepIn, ucInBuf, mInMaxPacketSize, 8000);            DisplayLog("read data");            DisplayLog(HexString.ByteToHexString(ucInBuf, bResult));            LogDriveUtil.d(TAG, "read data");            LogDriveUtil.d(TAG, HexString.ByteToHexString(ucInBuf, bResult));            if (bResult != mInMaxPacketSize && bResult != mInMaxPacketSize - 1) {                return 0x6FF2;            }            if (0xc3 == ucInBuf[1]) {                continue;            }            if (0x00 == (ucInBuf[1] & 0x20)) {                System.arraycopy(ucInBuf, 3, Receiveytes, ucBlockNo * (mInMaxPacketSize - 3), ucInBuf[2] - 2);                wRecvLen += ucInBuf[2] - 2;                break;            } else {                System.arraycopy(ucInBuf, 3, Receiveytes, ucBlockNo * (mInMaxPacketSize - 3), ucInBuf[2]);                wRecvLen += ucInBuf[2];            }            ucBlockNo++;        }        rlen[0] = wRecvLen;        wRetCode = (ucInBuf[ucInBuf[2] + 1] & 0xFF) << 8 | (ucInBuf[ucInBuf[2] + 2] & 0xFF);        if (mReaderType == 2 || mReaderType == 4) {            bResult = mDeviceConnection.bulkTransfer(mepIn, ucInBuf, mInMaxPacketSize, 1000);        }        return wRetCode;    }    public int CloseHIDReader() {        if (mDeviceConnection != null) {            mDeviceConnection.close();            mDeviceConnection = null;            isopen = false;        }        return 0;    }    public void SetNad(byte NAD) {        mnad = NAD;    }    private void DisplayLog(String str) {        Log.i(TAG, str);    }    public int ReadSFZ(int handle, Context context, String[] SFZInfo) {        byte[] IDCardData = new byte[1295];        int IDCarddatalen = 0;        IDCarddatalen = ReadIDCard(handle, IDCardData);        if (IDCarddatalen > 1000) {            return AnalyzeIDData(context, IDCardData, IDCarddatalen, SFZInfo);        } else {            return 1;        }    }    public static String bytesToHexString(byte[] bArray, int length) {        StringBuffer sb = new StringBuffer(length);        String sTemp;        for (int i = 0; i < length; i++) {            sTemp = Integer.toHexString(0xFF & bArray[i]);            if (sTemp.length() < 2)                sb.append(0);            sb.append(sTemp.toUpperCase());        }        return sb.toString();    }    public String GBK2Chinese(String GBKStr) throws Exception {        byte[] b = HexString2Bytes(GBKStr);        String chineseStr = new String(b, "gbk");//输入参数为字节数组        return chineseStr;    }    //把16进制字符串转换成字节数组    public byte[] HexString2Bytes(String hexStr) {        byte[] b = new byte[hexStr.length() / 2];        for (int i = 0; i < b.length; i++)            b[i] = (byte) Integer.parseInt(hexStr.substring(2 * i, 2 * i + 2), 16);        return b;    }//    public int ReadSSCard(byte nad, String[] SICardData) {//        NAD_READSBK = nad;//        Log.d(DEBUGTAG, "读社保卡方法");//        //继续下一步//        //读社保卡 （2代）//        byte[] idcarddata = new byte[3000];//        int idcarddatalen = 0;//        int res = 0;//        int len = 0;//        int sendLen = 0;//        int usercardVer = 0;//        char xbcode = 3;//        int[] pRevAPDULen = new int[1];//        byte[] pSendAPDU = new byte[512];//        byte[] pRecvRes = new byte[512];//        byte[] pRecvRestemp = new byte[4];//        byte[] pRecvRestemp1 = new byte[512];//        byte[] pRecvResVersion = {0x00, 0x00, 0x00, 0x00};//        byte[] pRecvResVersion1 = {0x31, 0x2E, 0x30, 0x30};//        byte[] pRecvResVersion2 = {0x32, 0x2E, 0x30, 0x30};//        byte[] pRecvResVersion3 = {0x33, 0x2E, 0x30, 0x30};//        int tempnumber = 0;//        String kh;//        String name;//        String nameex;//        String nation;//        String xingbie;//        String chsd;//        String chsrq;//        //TODO 非接15//        SetNad((byte) NAD_READSBK);//        pSendAPDU = HexString.hexStringToByte("0012000000");//复位//        res = HIDTransmit(pSendAPDU, pSendAPDU.length, pRecvRes, pRevAPDULen);//        if (res != 0x9000) {//            Log.d(DEBUGTAG, "复位失败" + res);//            return -res;//        }//        Log.d(DEBUGTAG, "复位成功test1");////        pSendAPDU = HexString.hexStringToByte("00A404000F7378312E73682EC9E7BBE1B1A3D5CF");//选择社保应用////        sendLen = pSendAPDU.length;////        res = HIDTransmit(pSendAPDU, sendLen, pRecvRes, pRevAPDULen);////        if ((res & 0xff00) == 0x6100) {////            byte[] cmd = HexString.hexStringToByte("00C0000000");////            cmd[4] = (byte) (res & 0x00ff);////            res = HIDTransmit(cmd, 5, pRecvRes, pRevAPDULen);////        }////        if (res != 0x9000) {////            return -res;////        }//////        byte[] AlgorithmID = new byte[1];//        byte[] gfbb = new byte[4];////////        int resultInt = selectSSSE(AlgorithmID, gfbb, true);//        if (resultInt != 0) {//            Log.e(DEBUGTAG, "读算法标识失败" + resultInt);//            return resultInt;//        }////        Log.i(DEBUGTAG, "算法标识： " + m_usercardAlg +//                "开发版本：" + HexSupport.toHexFromBytes(gfbb));//////        resultInt = findAndOpenPSAM();//        if (resultInt != 0) {//            Log.e(DEBUGTAG, "打开PSAM卡失败" + resultInt);//            return resultInt;//        }////        Log.i(DEBUGTAG, "打开PSAM卡成功");////        byte[] ATR = new byte[512];//        int[] ATRLen = new int[1];//        byte[] Index = new byte[512];//        int[] IndexLen = new int[1];//        resultInt = GetCardDivIndex(ATR, ATRLen, Index, IndexLen);////        byte[] tempIndex = new byte[IndexLen[0]];//        System.arraycopy(Index, 0, tempIndex, 0, IndexLen[0]);//////        if (resultInt != 0) {//            Log.e(DEBUGTAG, "取分散因子失败" + resultInt);//        }////        Log.i(DEBUGTAG, "取分散因子成功 ATR: " + HexSupport.toHexFromBytes(ATR)//                + "\n ATRLen: " + ATRLen[0]//                + "\n Index: " + HexSupport.toHexFromBytes(tempIndex)//                + "\n IndexLen: " + IndexLen[0]);////        //内部认证//        resultInt = InternalAuth((byte) 0x67, (byte) 0x08, tempIndex, IndexLen);//        if (resultInt != 0) {//            Log.e(DEBUGTAG, "内部认证 ERROR：" + resultInt);//            return resultInt;//        }////        Log.i(DEBUGTAG, "内部认证结果成功");////        //外部认证//        if (m_usercardAlg == CARD_V3) {//            resultInt = PSAMExterAuth((byte) 0x0A, (byte) 0x67, (byte) 0x0A, tempIndex, IndexLen);//            if (resultInt != 0) {//                Log.e(DEBUGTAG, "外部认证失败");//                return resultInt;//            }//            Log.d(DEBUGTAG, "外部认证成功");//        }////        //只要读规范版本文件失败就报版本问题//        SetNad((byte) NAD_READSBK);//        pSendAPDU = HexString.hexStringToByte("00A4000002EF05");//选择社保应用//        sendLen = pSendAPDU.length;//        res = HIDTransmit(pSendAPDU, sendLen, pRecvRes, pRevAPDULen);//        if (res == 0x6a82) {//            pSendAPDU = HexString.hexStringToByte("00A4020002EF05");//            sendLen = pSendAPDU.length;//            res = HIDTransmit(pSendAPDU, sendLen, pRecvRes, pRevAPDULen);//        }//        if (res != 0x9000) {////            return -res;//        }//        pSendAPDU = HexString.hexStringToByte("00B2030406");//读规范版本//        sendLen = pSendAPDU.length;//        res = HIDTransmit(pSendAPDU, sendLen, pRecvRes, pRevAPDULen);//        if (res != 0x9000) {//            return -res;//        }//        System.arraycopy(pRecvRes, 2, pRecvRestemp, 0, 4);////        if (Arrays.equals(pRecvRestemp, pRecvResVersion))//如果代码规范为空 代表为1.00版本的规范//        {//            System.arraycopy(pRecvResVersion1, 0, pRecvRestemp, 0, 4);//        }//        if (Arrays.equals(pRecvRestemp, pRecvResVersion1)) {//            usercardVer = 1;//        } else if (Arrays.equals(pRecvRestemp, pRecvResVersion2)) {//            usercardVer = 2;//        } else if (Arrays.equals(pRecvRestemp, pRecvResVersion3)) {//            usercardVer = 3;//        }//        //gfbb//////        pSendAPDU = HexString.hexStringToByte("00b207040b");//读卡号//        sendLen = pSendAPDU.length;//        res = HIDTransmit(pSendAPDU, sendLen, pRecvRes, pRevAPDULen);//        if ((res & 0xFF00) == 0x6C00) {//            pSendAPDU[4] = (byte) (res & 0x00FF);//            sendLen = pSendAPDU.length;//            res = HIDTransmit(pSendAPDU, sendLen, pRecvRes, pRevAPDULen);//        }//        if (res != 0x9000) {//            return -res;//        }//////        try {//            String TmpStr = new String(pRecvRes);//            SICardData[0] = TmpStr.substring(2, pRevAPDULen[0]);////        } catch (Exception e) {//            SICardData[0] = "";//        }//////        pSendAPDU = HexString.hexStringToByte("00A4000002EF06");//        sendLen = pSendAPDU.length;//        res = HIDTransmit(pSendAPDU, sendLen, pRecvRes, pRevAPDULen);//        if (res == 0x6A82) {//            pSendAPDU = HexString.hexStringToByte("00A4020002EF06");//选择社保应用//            sendLen = pSendAPDU.length;//            res = HIDTransmit(pSendAPDU, sendLen, pRecvRes, pRevAPDULen);//        }////        if (res != 0x9000) {//            return -res;//        }//////        //卡号//        pSendAPDU = HexString.hexStringToByte("00B2010414");//        sendLen = pSendAPDU.length;//        res = HIDTransmit(pSendAPDU, sendLen, pRecvRes, pRevAPDULen);//        if ((res & 0xFF00) == 0x6C00) {//            pSendAPDU[4] = (byte) (res & 0x00FF);//            sendLen = pSendAPDU.length;//            res = HIDTransmit(pSendAPDU, sendLen, pRecvRes, pRevAPDULen);//        }//        if (res != 0x9000) {//            return -res;//        }////        try {//            String TmpStr = new String(pRecvRes);//            SICardData[1] = TmpStr.substring(2, pRevAPDULen[0]);////        } catch (Exception e) {//            SICardData[1] = "";//        }//////        pSendAPDU = HexString.hexStringToByte("00B2020420");//姓名//        sendLen = pSendAPDU.length;//        res = HIDTransmit(pSendAPDU, sendLen, pRecvRes, pRevAPDULen);//        if ((res & 0xFF00) == 0x6C00) {//            pSendAPDU[4] = (byte) (res & 0x00FF);//            sendLen = pSendAPDU.length;//            res = HIDTransmit(pSendAPDU, sendLen, pRecvRes, pRevAPDULen);//        }//        if (res != 0x9000) {//            return -res;//        }//        //姓名//        try {//            String tmpStr = bytesToHexString(pRecvRes, pRevAPDULen[0]);//            SICardData[2] = GBK2Chinese(tmpStr.substring(4));//        } catch (Exception e) {//            SICardData[2] = "";//        }////        if (usercardVer == 2 || usercardVer == 3) {//            pSendAPDU = HexString.hexStringToByte("00B2030420");//扩展姓名//            sendLen = pSendAPDU.length;//            res = HIDTransmit(pSendAPDU, sendLen, pRecvRes, pRevAPDULen);//            if ((res & 0xFF00) == 0x6C00) {//                pSendAPDU[4] = (byte) (res & 0x00FF);//                sendLen = pSendAPDU.length;//                res = HIDTransmit(pSendAPDU, sendLen, pRecvRes, pRevAPDULen);//                tempnumber = 0;//                while ((res == 0x6FF2 || res == 0x6FF1) && tempnumber < 5) {//                    tempnumber++;//                    res = HIDTransmit(pSendAPDU, sendLen, pRecvRes, pRevAPDULen);//                }//            }//            if (res != 0x9000) {//扩展姓名失败//                return -res;//            }////        }//        if (usercardVer == 2 || usercardVer == 3) {//            xbcode = 4;//        }////        pSendAPDU = HexString.hexStringToByte("00B2030403");//性别//        pSendAPDU[2] = (byte) xbcode;//        sendLen = pSendAPDU.length;//        res = HIDTransmit(pSendAPDU, sendLen, pRecvRes, pRevAPDULen);//        if ((res & 0xFF00) == 0x6C00) {//            pSendAPDU[4] = (byte) (res & 0x00FF);//            sendLen = pSendAPDU.length;//            res = HIDTransmit(pSendAPDU, sendLen, pRecvRes, pRevAPDULen);//        }//        if (res != 0x9000) {//            return -res;//        }//        //性别//        if (pRecvRes[2] == '1') {//            try {//                String TmpStr = "男";//                SICardData[3] = TmpStr;////            } catch (Exception e) {//                SICardData[3] = "";//            }//        } else {//            try {//                String TmpStr = "女";//                SICardData[3] = TmpStr;////            } catch (Exception e) {//                SICardData[3] = "";//            }//        }////        pSendAPDU = HexString.hexStringToByte("00B2050403");//民族//        pSendAPDU[2] = (byte) (xbcode + 1);//        sendLen = pSendAPDU.length;//        res = HIDTransmit(pSendAPDU, sendLen, pRecvRes, pRevAPDULen);//        if ((res & 0xFF00) == 0x6C00) {//            pSendAPDU[4] = (byte) (res & 0x00FF);//            sendLen = pSendAPDU.length;//            res = HIDTransmit(pSendAPDU, sendLen, pRecvRes, pRevAPDULen);//        }//        if (res != 0x9000) {//            return -res;//        }////        //获取民族//        nation = decodeNation(pRecvRes[2]);//        try {//            SICardData[4] = nation;//        } catch (Exception e) {//            SICardData[4] = "";//        }//////        pSendAPDU = HexString.hexStringToByte("00B206040C");//出生地//        pSendAPDU[2] = (byte) (xbcode + 2);//        sendLen = pSendAPDU.length;//        res = HIDTransmit(pSendAPDU, sendLen, pRecvRes, pRevAPDULen);//        if ((res & 0xFF00) == 0x6C00) {//            pSendAPDU[4] = (byte) (res & 0x00FF);//            sendLen = pSendAPDU.length;//            res = HIDTransmit(pSendAPDU, sendLen, pRecvRes, pRevAPDULen);//        }//        if (res != 0x9000) {//            return -res;//        }////        byte[] csdByte = new byte[pRevAPDULen[0]];//        System.arraycopy(pRecvRes, 0, csdByte, 0, pRevAPDULen[0]);//        Log.d(DEBUGTAG, "出生地：" + HexSupport.toHexFromBytes(csdByte));////        try {//            String tmpStr = bytesToHexString(pRecvRes, pRevAPDULen[0]);//            SICardData[5] = tmpStr.substring(4);////        } catch (Exception e) {//            SICardData[5] = "";//        }//////        //读出生日期//        pSendAPDU = HexString.hexStringToByte("00B207040D");//        pSendAPDU[2] = (byte) (xbcode + 3);//        sendLen = pSendAPDU.length;//        res = HIDTransmit(pSendAPDU, sendLen, pRecvRes, pRevAPDULen);//        if ((res & 0xFF00) == 0x6C00) {//            pSendAPDU[4] = (byte) (res & 0x00FF);//            sendLen = pSendAPDU.length;//            res = HIDTransmit(pSendAPDU, sendLen, pRecvRes, pRevAPDULen);//        }//        if (res != 0x9000) {//            return -res;//        }////        try {//            String tmpStr = bytesToHexString(pRecvRes, pRevAPDULen[0]);//            SICardData[6] = tmpStr.substring(4);////        } catch (Exception e) {//            SICardData[6] = "";//        }//////        SICardData[7] = m_usercardAlg + "";////        //解析3代卡照片//        if (m_usercardAlg == CARD_V3) {//            byte[] headPicByte = new byte[10000];//            int[] headPicLen = new int[1];//            resultInt = getPersonHeadPic(headPicByte, headPicLen);//            if (resultInt != 0) {//                Log.e(DEBUGTAG, "取照片错误");//                return resultInt;//            }//            Log.i(DEBUGTAG, "取照片成功 \n长度 + " + headPicLen[0]//                    + "\n数据：" + HexSupport.toHexFromBytes(headPicByte));//////            byte[] realPicByte = new byte[headPicLen[0]];//            System.arraycopy(headPicByte, 0, realPicByte, 0, headPicLen[0]);//////            String base64 = Base64.encodeToString(realPicByte, Base64.NO_WRAP);//            SICardData[8] = base64;//            return 0;//        } else {//            return 0;//        }//    }    public int getPersonHeadPic(byte[] headPicByte, int[] headPicLen) {        //照片 SSSE_EF08        byte apdu_pp1 = 0;        byte apdu_pp2 = 0;        byte apdu_lc = (byte) 0x80;        byte[] photo_data = new byte[10000];        byte[] zero_data = new byte[255];        int photo_len = 0;        char i = 0;        byte[] photoBase64 = new byte[10000];        int slen = 7;        byte[] cmd = new byte[512];        System.arraycopy(HexSupport.toBytesFromHex("00A4000002EF08"), 0, cmd, 0, 7);        byte[] pRecvRes = new byte[512];        int[] pRevAPDULen = new int[1];        SetNad((byte) NAD_READSBK);        Log.d(DEBUGTAG, "解析照片信息 复位成功");        int res = HIDTransmit(cmd, slen, pRecvRes, pRevAPDULen);        if (res != 0x9000) {            Log.e(DEBUGTAG, "cmd 指令失败 Error" + res);            return apduErrTanslation(res);        }        byte[] tempRes = new byte[255];        do {            Log.v(DEBUGTAG, "照片循环");            slen = 5;            System.arraycopy(HexSupport.toBytesFromHex("00B0000080"), 0, cmd, 0, 5);            cmd[2] = apdu_pp1;            cmd[3] = apdu_pp2;            res = HIDTransmit(cmd, slen, pRecvRes, pRevAPDULen);            if (res != 0x9000) {                Log.d(DEBUGTAG, "cmd 指令失败 Error" + res);                return apduErrTanslation(res);            }            System.arraycopy(pRecvRes, 0, tempRes, 0, 255);            Log.v(DEBUGTAG, "照片循环数据1 " + HexSupport.toHexFromBytes(tempRes));            Log.v(DEBUGTAG, "照片循环数据2 " + HexSupport.toHexFromBytes(zero_data) + "\n");            System.arraycopy(pRecvRes, 0, photo_data, photo_len, pRevAPDULen[0]);            photo_len += pRevAPDULen[0];            apdu_pp1 = (byte) (photo_len / 256);            apdu_pp2 = (byte) (photo_len % 256);//(unsigned char)photo_len;            //BinToCHex((unsigned char*)logbuf, rsp, 0x80);            //Addlog(logbuf);            //不是全0就循环        } while (!HexSupport.toHexFromBytes(tempRes).equals(HexSupport.toHexFromBytes(zero_data)));        photo_len = photo_len - 255; //最后一包数据是0，去掉,        Log.d(DEBUGTAG, "photoLen = " + photo_len);        for (i = 1; i <= 255; i++) {            if (photo_data[photo_len - i] == 0) {            } else {                photo_len = photo_len - i + 1;                break;            }        }        Log.d(DEBUGTAG, "长度" + photo_len +                "\n照片数据方法内部 " + HexSupport.toHexFromBytes(photo_data));        System.arraycopy(photo_data, 0, headPicByte, 0, photo_len);        headPicLen[0] = photo_len;        return 0;    }    /**     * 外部认证     *     * @param userKeyID     * @param KeyUse     * @param PSAMKeyID     * @param divindex     * @param divindexlen     * @return     */    private int PSAMExterAuth(byte userKeyID, byte KeyUse, byte PSAMKeyID, byte[] divindex, int[] divindexlen) {        byte[] CryptRand = new byte[64];        int[] CryptRandlen = new int[]{8};        byte[] SessionRand = new byte[64];        int[] SessionRandlen = new int[]{8};        if (m_usercardAlg == SSFF33_ALG || m_usercardAlg == SM4_ALG) {            SessionRandlen[0] = CryptRandlen[0] = 16;        }        byte[] cmd = new byte[512];        System.arraycopy(HexSupport.toBytesFromHex("0084000008"), 0, cmd, 0, 5);        int cmdLen = 5;        int[] pRevAPDULen = new int[1];        byte[] pSendAPDU = new byte[512];        byte[] pRecvRes = new byte[512];        SetNad((byte) NAD_READSBK);        int res = HIDTransmit(cmd, cmdLen, CryptRand, pRevAPDULen);        if (res != 0x9000) {            Log.e(DEBUGTAG, "0084000008  ERROR " + res);            return apduErrTanslation(res);        }        res = HIDTransmit(cmd, cmdLen, SessionRand, pRevAPDULen);        if (res != 0x9000) {            Log.e(DEBUGTAG, "0084000008  ERROR " + res);            return apduErrTanslation(res);        }        Log.d(DEBUGTAG, "随机数： Cry " + HexSupport.toHexFromBytes(CryptRand));        Log.d(DEBUGTAG, "随机数： Ses " + HexSupport.toHexFromBytes(SessionRand));        byte[] data = new byte[512];        int[] datalen = new int[1];        res = PSAMDes(KeyUse, PSAMKeyID,                divindex, divindexlen,                CryptRand, CryptRandlen,                SessionRand, SessionRandlen,                data, datalen);        if (res != 0) {            return res;        }        Log.d(DEBUGTAG, "出参数： data " + HexSupport.toHexFromBytes(data));        if (m_usercardAlg == SSFF33_ALG || m_usercardAlg == SM4_ALG) {            Log.d(DEBUGTAG, "进行异或运算");            for (int i = 0; i < 8; i++) {                data[i] = (byte) (data[i] ^ data[8 + i]);            }        }        SetNad((byte) NAD_READSBK);        System.arraycopy(HexSupport.toBytesFromHex("0082000010"), 0, cmd, 0, 5);        cmd[3] = userKeyID;        System.arraycopy(data, 0, cmd, 5, 8);        cmdLen = 5 + 8;        System.arraycopy(CryptRand, 0, cmd, cmdLen, 8);        cmdLen += 8;        Log.d(DEBUGTAG, "外部认证 cmd = " + HexSupport.toHexFromBytes(cmd));        res = HIDTransmit(cmd, cmdLen, pRecvRes, pRevAPDULen);        if (res != 0x9000) {            Log.e(DEBUGTAG, "0082000010  ERROR " + res);            return apduErrTanslation(res);        }        return 0;    }    int m_usercardAlg = -1;    /**     * 选择社保应用，并返回算法标识     *     * @param algorithmID  出参     * @param gfbb         出参     * @param checkCardVer 入参     */    public int selectSSSE(byte[] algorithmID, byte[] gfbb, boolean checkCardVer) {        Log.d(DEBUGTAG, "selectSSSE 方法已调用");        //发指令统一代码，以复位举例        int[] pRevAPDULen = new int[1];        byte[] pSendAPDU = new byte[512];        byte[] pRecvRes = new byte[512];        //TODO 非接15        SetNad((byte) NAD_READSBK);        //复位        pSendAPDU = HexString.hexStringToByte("0012000000");        int res = HIDTransmit(pSendAPDU, pSendAPDU.length, pRecvRes, pRevAPDULen);        if (res != 0x9000) {            return -res;        }        Log.d(DEBUGTAG, "复位成功");        pSendAPDU = HexString.hexStringToByte("00A404000F7378312E73682EC9E7BBE1B1A3D5CF");        res = HIDTransmit(pSendAPDU, pSendAPDU.length, pRecvRes, pRevAPDULen);        if ((res & 0xff00) == 0x6100) {            byte[] cmd = HexString.hexStringToByte("00C0000000");            cmd[4] = (byte) (res & 0x00ff);            res = HIDTransmit(cmd, 5, pRecvRes, pRevAPDULen);        }        if (res != 0x9000) {            return -res;        }        byte[] tlvResult = new byte[512];        int Len6F = tag_decodetlv(pRecvRes.length, HexString2Bytes("6F"), pRecvRes, tlvResult);        Log.d(DEBUGTAG, "6f字节数组长度：" + Len6F);        byte[] tempResult = new byte[Len6F];        System.arraycopy(tlvResult, 0, tempResult, 0, Len6F);        Log.d(DEBUGTAG, "6f字节数组长度：" + HexSupport.toHexFromBytes(tempResult));        byte[] tempResult2 = new byte[Len6F - 2];        //去掉结果的前两个字节        System.arraycopy(tempResult, 2, tempResult2, 0, Len6F - 2);        byte[] tlvResultA5 = new byte[512];        int LenA5 = tag_decodetlv(tempResult2.length, HexString2Bytes("A5"), tempResult2, tlvResultA5);        Log.d(DEBUGTAG, "A5字节数组长度：" + LenA5);        byte[] tempResultA5 = new byte[LenA5];        System.arraycopy(tlvResultA5, 0, tempResultA5, 0, LenA5);        Log.d(DEBUGTAG, "A5字节数组长度：" + HexSupport.toHexFromBytes(tempResultA5));        byte[] tempResultA52 = new byte[LenA5 - 2];        //去掉结果的前两个字节        System.arraycopy(tempResultA5, 2, tempResultA52, 0, LenA5 - 2);        byte[] tlvResult9F = new byte[512];        int Len9F = tag_decodetlv(tempResultA52.length, HexString2Bytes("9F0C"), tempResultA52, tlvResult9F);        Log.d(DEBUGTAG, "9F字节数组长度：" + Len9F);        byte[] tempResult9F = new byte[Len9F];        System.arraycopy(tlvResult9F, 0, tempResult9F, 0, Len9F);        Log.d(DEBUGTAG, "9F字节数组长度：" + HexSupport.toHexFromBytes(tempResult9F));        if (Len6F == 5) {            algorithmID[0] = tempResult9F[4];        } else {            //去掉结果的前两个字节            if (tempResult9F.length >= 3) {                byte[] tempResult9F2 = new byte[tempResult9F.length - 3];                System.arraycopy(tempResult9F, 3, tempResult9F2, 0, 3);                byte[] result86 = new byte[512];                int Len86 = tag_decodetlv(tempResult9F2.length, HexString2Bytes("86"), tempResult9F2, result86);                Log.d(DEBUGTAG, "86字节数组长度：" + Len86);                byte[] tempResult86 = new byte[Len86];                System.arraycopy(result86, 0, tempResult86, 0, Len86);                Log.d(DEBUGTAG, "86字节数组长度：" + HexSupport.toHexFromBytes(tempResult86));                if (tempResult86.length > 2 && tempResult86[2] > 0) {                    algorithmID[0] = tempResult86[2];                    Log.d(DEBUGTAG, "算法标识：" + algorithmID[0]);                } else {                    String hexSendData = "00A4000002EF05";                    pSendAPDU = HexSupport.toBytesFromHex(hexSendData);                    res = HIDTransmit(pSendAPDU, pSendAPDU.length, pRecvRes, pRevAPDULen);                    if (res != 0x9000) {                        Log.e(DEBUGTAG, "00A4000002EF05失败");                        return -res;                    }                    hexSendData = "00B2010412";                    pSendAPDU = HexSupport.toBytesFromHex(hexSendData);                    res = HIDTransmit(pSendAPDU, pSendAPDU.length, pRecvRes, pRevAPDULen);                    if (res != 0x9000) {                        Log.e(DEBUGTAG, "00B2010412 失败");                        return -res;                    }                    if (pRecvRes[2] == 0x11) {                        algorithmID[0] = SSFF33_ALG;                        Log.d(DEBUGTAG, "算法标识：" + algorithmID[0]);                    } else {                        algorithmID[0] = DES_ALG;                        Log.d(DEBUGTAG, "算法标识：" + algorithmID[0]);                    }                }            } else {                String hexSendData = "00A4000002EF05";                pSendAPDU = HexSupport.toBytesFromHex(hexSendData);                res = HIDTransmit(pSendAPDU, pSendAPDU.length, pRecvRes, pRevAPDULen);                if (res != 0x9000) {                    Log.e(DEBUGTAG, "00A4000002EF05失败");                    return -res;                }                hexSendData = "00B2010412";                pSendAPDU = HexSupport.toBytesFromHex(hexSendData);                res = HIDTransmit(pSendAPDU, pSendAPDU.length, pRecvRes, pRevAPDULen);                if (res != 0x9000) {                    Log.e(DEBUGTAG, "00B2010412 失败");                    return -res;                }                if (pRecvRes[2] == 0x11) {                    algorithmID[0] = SSFF33_ALG;                    Log.d(DEBUGTAG, "算法标识：" + algorithmID[0]);                } else {                    algorithmID[0] = DES_ALG;                    Log.d(DEBUGTAG, "算法标识：" + algorithmID[0]);                }            }        }        m_usercardAlg = algorithmID[0];        Log.d(DEBUGTAG, "m_usercardAlg 算法版本：" + m_usercardAlg);        String hexSendData = "00A4000002EF05";        pSendAPDU = HexSupport.toBytesFromHex(hexSendData);        res = HIDTransmit(pSendAPDU, pSendAPDU.length, pRecvRes, pRevAPDULen);        if (res != 0x9000) {            Log.e(DEBUGTAG, "00A4000002EF05 失败");            return -res;        }        hexSendData = "00B2030406";        pSendAPDU = HexSupport.toBytesFromHex(hexSendData);        res = HIDTransmit(pSendAPDU, pSendAPDU.length, pRecvRes, pRevAPDULen);        if (res != 0x9000) {            Log.e(DEBUGTAG, "00B2030406 失败");            return -res;        }        System.arraycopy(pRecvRes, 2, gfbb, 0, 4);        /*         * 判断几代社保卡         */        int m_usercardVer = -1;        if (HexSupport.toHexFromBytes(gfbb).equals("00000000")) {            m_usercardVer = CARD_V1;            System.arraycopy("1.00".getBytes(), 0, gfbb, 0, 4);        } else {            hexSendData = "00B2010412";            pSendAPDU = HexSupport.toBytesFromHex(hexSendData);            res = HIDTransmit(pSendAPDU, pSendAPDU.length, pRecvRes, pRevAPDULen);            if (res != 0x9000) {                Log.e(DEBUGTAG, "00B2010412 失败");                return -res;            }            byte[] tempgfbb3 = new byte[3];            System.arraycopy(gfbb, 0, tempgfbb3, 0, 3);            Log.d(DEBUGTAG, "pRecvRes[2]" + HexSupport.toHexFromByte(pRecvRes[2]));            Log.d(DEBUGTAG, "tempgfbb3 " + HexSupport.toHexFromBytes(tempgfbb3));            Log.d(DEBUGTAG, "gfbb " + HexSupport.toHexFromBytes(gfbb));            switch (pRecvRes[2]) {                case 0x14:                case 0x15:                case 0x35:                    if (gfbb[0] == 2) {                        System.arraycopy("1.00".getBytes(), 0, gfbb, 0, 4);                        m_usercardVer = CARD_V1;                    } else if (HexSupport.toHexFromBytes("1.0".getBytes()).equals(                            HexSupport.toHexFromBytes(tempgfbb3)                    )) {                        m_usercardVer = CARD_V1;                    } else if (HexSupport.toHexFromBytes("2.0".getBytes()).equals(                            HexSupport.toHexFromBytes(tempgfbb3)                    )) {                        m_usercardVer = CARD_V2;                    } else if (HexSupport.toHexFromBytes("3.0".getBytes()).equals(                            HexSupport.toHexFromBytes(tempgfbb3)                    )) {                        m_usercardVer = CARD_V3;                    } else {                        System.arraycopy("0.00".getBytes(), 0, gfbb, 0, 4);                        m_usercardVer = CARD_VERR;                    }                    break;                case 0x33:                    if (gfbb[0] == 1) {                        System.arraycopy("1.00".getBytes(), 0, gfbb, 0, 4);                        m_usercardVer = CARD_V1;                    } else if (HexSupport.toHexFromBytes("1.0".getBytes()).equals(                            HexSupport.toHexFromBytes(tempgfbb3)                    )) {                        m_usercardVer = CARD_V1;                    } else if (HexSupport.toHexFromBytes("2.0".getBytes()).equals(                            HexSupport.toHexFromBytes(tempgfbb3)                    )) {                        m_usercardVer = CARD_V2;                    } else if (HexSupport.toHexFromBytes("3.0".getBytes()).equals(                            HexSupport.toHexFromBytes(tempgfbb3)                    )) {                        m_usercardVer = CARD_V3;                    } else {                        System.arraycopy("0.00".getBytes(), 0, gfbb, 0, 4);                        m_usercardVer = CARD_VERR;                    }                    break;                default:                    if (HexSupport.toHexFromBytes("1.0".getBytes()).equals(                            HexSupport.toHexFromBytes(tempgfbb3)                    )) {                        m_usercardVer = CARD_V1;                    } else if (HexSupport.toHexFromBytes("2.0".getBytes()).equals(                            HexSupport.toHexFromBytes(tempgfbb3)                    )) {                        m_usercardVer = CARD_V2;                    } else if (HexSupport.toHexFromBytes("3.0".getBytes()).equals(                            HexSupport.toHexFromBytes(tempgfbb3)                    )) {                        m_usercardVer = CARD_V3;                    } else {                        System.arraycopy("0.00".getBytes(), 0, gfbb, 0, 4);                        m_usercardVer = CARD_VERR;                    }                    break;            }        }        if (m_usercardVer == CARD_VERR && checkCardVer) {            return ErrorCodeConstant.ERR_ID_CODE;        }        return ErrorCodeConstant.RSP_OK;    }    public int findAndOpenPSAM() {        Log.d(DEBUGTAG, "findAndOpenPSAM 已调用");        //发指令统一代码，以复位举例        int[] pRevAPDULen = new int[1];        byte[] pSendAPDU = new byte[512];        byte[] pRecvRes = new byte[512];        SetNad((byte) 0x16);        //复位        pSendAPDU = HexString.hexStringToByte("0012000000");        int res = HIDTransmit(pSendAPDU, pSendAPDU.length, pRecvRes, pRevAPDULen);        if (res != 0x9000) {            return -res;        }        Log.d(DEBUGTAG, "findAndOpenPSAM 复位成功");        if (m_usercardAlg == DES_ALG) {        } else if (m_usercardAlg == SSFF33_ALG) {            pSendAPDU = HexString.hexStringToByte("00A404000F7378322E73682EC9E7BBE1B1A3D5CF");            res = HIDTransmit(pSendAPDU, pSendAPDU.length, pRecvRes, pRevAPDULen);            if (res != 0x9000) {                Log.e(DEBUGTAG, "SSFF33 ERROr " + res);                return ErrorCodeConstant.ERR_PSAM_ALGO;            }        } else if (m_usercardAlg == SM4_ALG) {            pSendAPDU = HexSupport.toBytesFromHex("00A404000F7378332E73682EC9E7BBE1B1A3D5CF");            res = HIDTransmit(pSendAPDU, pSendAPDU.length, pRecvRes, pRevAPDULen);            if ((res & 0xff00) == 0x6100) {                byte[] cmd = HexString.hexStringToByte("00C0000000");                cmd[4] = (byte) (res & 0x00ff);                res = HIDTransmit(cmd, 5, pRecvRes, pRevAPDULen);            }            if (res != 0x9000) {                Log.e(DEBUGTAG, "SM4_ALG ERROr " + res);                return ErrorCodeConstant.ERR_PSAM_ALGO;            }        }        return 0;    }    byte usrCardCityCode[] = new byte[3];    /**     * 获取分散因子     *     * @param ATR      出参     * @param ATRLen   出参     * @param Index    出参     * @param IndexLen 出参     * @return     */    public int GetCardDivIndex(byte[] ATR, int[] ATRLen, byte[] Index, int[] IndexLen) {        Log.d(DEBUGTAG, "GetCardDivIndex 已调用");        //发指令统一代码，以复位举例        int[] pRevAPDULen = new int[1];        byte[] pSendAPDU = new byte[512];        byte[] pRecvRes = new byte[512];        SetNad((byte) NAD_READSBK);        //复位        pSendAPDU = HexString.hexStringToByte("0012000000");        int res = HIDTransmit(pSendAPDU, pSendAPDU.length, ATR, ATRLen);        if (res != 0x9000) {            return -res;        }        Log.d(DEBUGTAG, "GetCardDivIndex 复位成功");        //选择应用环境，获取分散因子        System.arraycopy(ATR, ATRLen[0] - 8, Index, 0, 8);        pSendAPDU = HexString.hexStringToByte("00A404000F7378312E73682EC9E7BBE1B1A3D5CF");        res = HIDTransmit(pSendAPDU, pSendAPDU.length, pRecvRes, pRevAPDULen);        if ((res & 0xff00) == 0x6100) {            byte[] cmd = HexString.hexStringToByte("00C0000000");            cmd[4] = (byte) (res & 0x00ff);            res = HIDTransmit(cmd, 5, pRecvRes, pRevAPDULen);        }        if (res != 0x9000) {            Log.e(DEBUGTAG, "00A404000F7378312E73682EC9E7BBE1B1A3D5CF  错误" + res);            return res;        }        pSendAPDU = HexString.hexStringToByte("00A4000002EF05");        res = HIDTransmit(pSendAPDU, pSendAPDU.length, pRecvRes, pRevAPDULen);        if (res != 0x9000) {            Log.e(DEBUGTAG, "00A4000002EF05  错误" + res);            return res;        }        pSendAPDU = HexString.hexStringToByte("00B2010412");        res = HIDTransmit(pSendAPDU, pSendAPDU.length, pRecvRes, pRevAPDULen);        if (res != 0x9000) {            Log.e(DEBUGTAG, "00B2010412  错误" + res);            return res;        }        System.arraycopy(pRecvRes, 2, usrCardCityCode, 0, 3);        Log.d(DEBUGTAG, "城市代码：" + HexSupport.toHexFromBytes(usrCardCityCode));        if (HexSupport.toHexFromByte(pRecvRes[2]).equals("33")) {            Log.d(DEBUGTAG, "是33");            byte[] temp2Byte = new byte[2];            System.arraycopy(pRecvRes, 2, temp2Byte, 0, 2);            String s = HexSupport.toHexFromBytes(temp2Byte);            System.arraycopy(s.getBytes(), 0, Index, 0, 4);            System.arraycopy(pRecvRes, 2, Index, 8, 4);            System.arraycopy("00".getBytes(), 0, Index, 12, 2);        } else {            Log.d(DEBUGTAG, "不是33");//            System.arraycopy(pRecvRes, 2, Index, 8, 6);            System.arraycopy(HexSupport.toHexFromByte(pRecvRes[2]).getBytes(), 0, Index, 8, 2);            System.arraycopy(HexSupport.toHexFromByte(pRecvRes[3]).getBytes(), 0, Index, 10, 2);            System.arraycopy(HexSupport.toHexFromByte(pRecvRes[4]).getBytes(), 0, Index, 12, 2);        }        IndexLen[0] = 14;        System.arraycopy(HexSupport.toBytesFromHex("7378"), 0, Index, IndexLen[0], 2);        IndexLen[0] = 16;        byte[] temp2Byte = new byte[3];        System.arraycopy(pRecvRes, 2, temp2Byte, 0, 1);        String s = HexSupport.toHexFromBytes(temp2Byte);        System.arraycopy(s.getBytes(), 0, Index, IndexLen[0], 2);        IndexLen[0] = 18;        System.arraycopy(HexSupport.toBytesFromHex("303030307368"), 0, Index, IndexLen[0], 6);        IndexLen[0] = 24;        return 0;    }    //ret = InternalAuth(hreader,0x67,0x08,Index,Indexlen);    /**     * @param KeyUse      写死     * @param PSAMKeyID   写死     * @param divindex    出参字节数组     * @param divindexlen 出餐字节数组长度     * @return     */    public int InternalAuth(byte KeyUse, byte PSAMKeyID, byte[] divindex, int[] divindexlen) {        Log.d(DEBUGTAG, "内部认证开始");        byte[] CryptRand = new byte[64];        int[] CryptRandlen = new int[]{8};        byte[] SessionRand = new byte[64];        int[] SessionRandlen = new int[]{8};        int[] rlen = new int[1];        //内部认证        if (m_usercardAlg == SSFF33_ALG || m_usercardAlg == SM4_ALG) {            SessionRandlen[0] = CryptRandlen[0] = 16;        }        //发指令统一代码，以复位举例        SetNad((byte) NAD_READSBK);        byte[] cmd = new byte[512];        System.arraycopy(HexSupport.toBytesFromHex("0084000008"), 0, cmd, 0, 5);        int cmdLen = 5;        int res = HIDTransmit(cmd, cmdLen, CryptRand, rlen);        if (res != 0x9000) {            return apduErrTanslation(res);        }        Log.d(DEBUGTAG, "内部认证 CryptRand = " + HexSupport.toHexFromBytes(CryptRand) + " \n长度 " + CryptRandlen[0]);        res = HIDTransmit(cmd, cmdLen, SessionRand, rlen);        if (res != 0x9000) {            return apduErrTanslation(res);        }        Log.d(DEBUGTAG, "内部认证 SessionRand = " + HexSupport.toHexFromBytes(SessionRand) + " \n长度 " + SessionRandlen[0]);        byte[] des1 = new byte[64];        byte[] des2 = new byte[64];        int[] des2len = new int[1];//        if (BuildConfig.DEBUG) {//            System.arraycopy(HexSupport.toBytesFromHex("DEBD1BEA0DEE040B0000000000000000"), 0, SessionRand, 0, 16);//            System.arraycopy(HexSupport.toBytesFromHex("D705A47EF5243EA90000000000000000"), 0, CryptRand, 0, 16);//        }        int result = PSAMDes(KeyUse, PSAMKeyID,                divindex, divindexlen,                CryptRand, CryptRandlen,                SessionRand, SessionRandlen,                des2, des2len        );        if (result != 0) {            Log.e(DEBUGTAG, "PSAMDes ERROR " + result);            return result;        }        Log.d(DEBUGTAG, "PSAMDes 成功了...");        if (m_usercardAlg == SSFF33_ALG || m_usercardAlg == SM4_ALG) {            for (int i = 0; i < 8; i++) {                des2[i] = (byte) (des2[i] ^ des2[8 + i]);            }        }        SetNad((byte) NAD_READSBK);        System.arraycopy(HexSupport.toBytesFromHex("0088000010"), 0, cmd, 0, 5);        System.arraycopy(SessionRand, 0, cmd, 5, 8);        System.arraycopy(CryptRand, 0, cmd, 13, 8);        cmdLen = 21;        byte[] pRecvRes = new byte[512];        int[] pRevAPDULen = new int[1];        res = HIDTransmit(cmd, cmdLen, des1, rlen);        if ((res & 0xff00) == 0x6100) {            cmd = HexString.hexStringToByte("00C0000000");            cmd[4] = (byte) (res & 0x00ff);            res = HIDTransmit(cmd, 5, des1, pRevAPDULen);        }        if (res != 0x9000) {            Log.e(DEBUGTAG, "0088000010" + "失败");            return apduErrTanslation(res);        }        if (HexSupport.toHexFromBytes(des1).substring(0, 16).equals(                HexSupport.toHexFromBytes(des2).substring(0, 16)        )) {            return 0;        } else {            return -1;        }    }    /**     * @param KeyUse     * @param PSAMKeyID     * @param divindex     * @param divindexlen     * @param data     * @param datalen     * @param Cryptdata     出参     * @param Cryptdatalen  出参     * @param SesionRand     * @param SesionRandlen     * @return     */    private int PSAMDes(byte KeyUse, byte PSAMKeyID,                        byte[] divindex, int[] divindexlen,                        byte[] Cryptdata, int[] Cryptdatalen,                        byte[] SesionRand, int[] SesionRandlen,                        byte[] data, int[] datalen) {        Log.d(DEBUGTAG, "PSAMDes 开始调用 " + HexSupport.toHexFromBytes(divindex)                + " \n SesionRand" + HexSupport.toHexFromBytes(SesionRand)                + " \n Cryptdata" + HexSupport.toHexFromBytes(Cryptdata)                + " \n长度 SesionRandlen = " + SesionRandlen[0] + "\n长度 Cryptdatalen =" + Cryptdatalen[0]);        //发指令统一代码，以复位举例        int[] pRevAPDULen = new int[1];        byte[] pSendAPDU = new byte[512];        byte[] pRecvRes = new byte[512];        SetNad((byte) 0x16);        //复位        pSendAPDU = HexString.hexStringToByte("0012000000");        int res = HIDTransmit(pSendAPDU, pSendAPDU.length, pRecvRes, pRevAPDULen);        if (res != 0x9000) {            Log.e(DEBUGTAG, "0012000000 ERROR！" + res);            return apduErrTanslation(res);        }        Log.i(DEBUGTAG, "PSAMDes 复位成功");        if (m_usercardAlg == SSFF33_ALG) {            Log.d(DEBUGTAG, "SSFF33");            pSendAPDU = HexSupport.toBytesFromHex("00A404000F7378322E73682EC9E7BBE1B1A3D5CF");            res = HIDTransmit(pSendAPDU, pSendAPDU.length, pRecvRes, pRevAPDULen);            if (res != 0x9000) {                Log.e(DEBUGTAG, "00A404000F7378322E73682EC9E7BBE1B1A3D5CF ERROR！" + res);                return res;            }        } else if (m_usercardAlg == SM4_ALG) {            Log.d(DEBUGTAG, "SSFF33");            pSendAPDU = HexString.hexStringToByte("00A404000F7378332E73682EC9E7BBE1B1A3D5CF");            res = HIDTransmit(pSendAPDU, pSendAPDU.length, pRecvRes, pRevAPDULen);            if ((res & 0xff00) == 0x6100) {                byte[] cmd = HexString.hexStringToByte("00C0000000");                cmd[4] = (byte) (res & 0x00ff);                res = HIDTransmit(cmd, 5, pRecvRes, pRevAPDULen);            }            if (res != 0x9000) {                Log.e(DEBUGTAG, "00A404000F7378332E73682EC9E7BBE1B1A3D5CF ERROR！" + res);                return res;            }        }        byte[] TerminalNo = new byte[6];        pSendAPDU = HexString.hexStringToByte("00A40000020016");        res = HIDTransmit(pSendAPDU, pSendAPDU.length, pRecvRes, pRevAPDULen);        if (res != 0x9000) {            TerminalNo = HexSupport.toBytesFromHex("000000000000");        } else {            Log.d(DEBUGTAG, "终端机编号返回不是9000");            pSendAPDU = HexString.hexStringToByte("00B0000006");            res = HIDTransmit(pSendAPDU, pSendAPDU.length, pRecvRes, pRevAPDULen);            if (res != 0x9000) {                return res;            }            System.arraycopy(pRecvRes, 0, TerminalNo, 0, 6);        }        Log.d(DEBUGTAG, "终端号：" + HexSupport.toHexFromBytes(TerminalNo));        pSendAPDU = HexString.hexStringToByte("00A4000002DF01");        res = HIDTransmit(pSendAPDU, pSendAPDU.length, pRecvRes, pRevAPDULen);        if ((res & 0xff00) == 0x6100) {            byte[] cmd = HexString.hexStringToByte("00C0000000");            cmd[4] = (byte) (res & 0x00ff);            res = HIDTransmit(cmd, 5, pRecvRes, pRevAPDULen);        }        if (res != 0x9000) {            Log.e(DEBUGTAG, "00A4000002DF01 ERROR！" + res);            return apduErrTanslation(res);        }        byte fensanjishu = (byte) ((KeyUse & 0xE0) >> 5);        Log.d(DEBUGTAG, "分散基数：" + fensanjishu);        byte[] cmd = new byte[512];        System.arraycopy(HexSupport.toBytesFromHex("BFDE670818"), 0, cmd, 0, 5);        int cmdLen = 5;        while (fensanjishu > 0) {            Log.d(DEBUGTAG, "内部认证循环：" + fensanjishu);            int retcode = VerifyKeyLevel(fensanjishu, usrCardCityCode, TerminalNo);            if (retcode != ErrorCodeConstant.RSP_OK) {                return retcode;            }            cmd[2] = (byte) ((KeyUse & 0x1F) | (fensanjishu << 5));            cmd[3] = PSAMKeyID;            System.arraycopy(divindex, 0, cmd, cmdLen, fensanjishu * 8);            cmdLen = 5 + fensanjishu * 8;            System.arraycopy(SesionRand, 0, cmd, cmdLen, SesionRandlen[0]);            cmdLen = cmdLen + SesionRandlen[0];            cmd[4] = (byte) (cmdLen - 5);            Log.d(DEBUGTAG, "While 循环里面的指令：" + HexSupport.toHexFromBytes(cmd));            res = HIDTransmit(cmd, cmdLen, pRecvRes, pRevAPDULen);            if (res == 0x6A88) {                Log.d(DEBUGTAG, "指令返回 6A88");                if (fensanjishu == 1) {                    return ErrorCodeConstant.ERR_PSAM_KEY_LEVEL;                } else {                    fensanjishu--;                }            } else if (res == 0x9000) {                Log.d(DEBUGTAG, "指令返回 9000");                break;            } else {                Log.d(DEBUGTAG, "指令返回其他");                return apduErrTanslation(res);            }        }        //80FA000008        System.arraycopy(HexSupport.toBytesFromHex("80FA000008"), 0, cmd, 0, 5);        cmd[4] = (byte) Cryptdatalen[0];        System.arraycopy(Cryptdata, 0, cmd, 5, Cryptdatalen[0]);        cmdLen = 5 + Cryptdatalen[0];        Log.d(DEBUGTAG, "Des最后发了什么 = " + HexSupport.toHexFromBytes(cmd) + "\n 长度 " + cmdLen);        res = HIDTransmit(cmd, cmdLen, Cryptdata, Cryptdatalen);        Log.d(DEBUGTAG, "结果码：" + res);        if ((res & 0xff00) == 0x6100) {            cmd = HexString.hexStringToByte("00C0000000");            cmd[4] = (byte) (res & 0x00ff);            res = HIDTransmit(cmd, 5, data, datalen);        }        if (res != 0x9000) {            Log.e(DEBUGTAG, "Des最后一步 ERROR！" + res);            return apduErrTanslation(res);        }        return 0;    }    int VerifyKeyLevel(byte fensanjishu, byte[] usercardCityCode, byte[] TerminalNo) {        int retcode = ErrorCodeConstant.RSP_OK;        switch (fensanjishu) {            case 3: // 国家级密钥                retcode = ErrorCodeConstant.RSP_OK;                break;            case 2://省级密钥                if (usercardCityCode[0] == TerminalNo[0]) {                    retcode = ErrorCodeConstant.ERR_PSAM_KEY_LEVEL;                }                break;            case 1://市级密钥                if (HexSupport.toHexFromBytes(usercardCityCode).equals(                        HexSupport.toHexFromBytes(TerminalNo).substring(0, 6)                )) {                    retcode = ErrorCodeConstant.ERR_PSAM_KEY_LEVEL;                }                break;            default:                retcode = ErrorCodeConstant.ERR_PSAM_KEY_LEVEL;                break;        }        return retcode;    }    /**     * @param tagInputTotal     * @param tagInputTag     * @param tagInputBuffA     设备返回的数组     * @param tagOutputBuffATLV     * @return     */    int tag_decodetlv(int tagInputTotal, byte tagInputTag[], byte tagInputBuffA[], byte tagOutputBuffATLV[]) {        int i = 0, j = 0, k = 0;        byte ret = 0, locTagLength, inputTagLength;        byte loctag[] = new byte[2];        int tagOutputTotal = 0;        /*get the input tag's length*/        if ((tagInputTag[0] & 0x1F) == 0x1F) {            inputTagLength = 2;        } else {            inputTagLength = 1;        }        /*start the search*/        locTagLength = 1;        for (i = 0; i < tagInputTotal; ) {            if ((tagInputBuffA[i] == 0x00) || (tagInputBuffA[i] == 0xff)) {                i++;                continue;            }            /*get the tag's value*/            loctag[0] = tagInputBuffA[i];            if ((loctag[0] & 0x1F) == 0x1F) {                loctag[1] = tagInputBuffA[i + 1];                locTagLength = 2;            } else {                locTagLength = 1;            }            /*get the tag's value's length*/            if (tagInputBuffA[i + locTagLength] == 0x81) {                j = 2 + tagInputBuffA[i + locTagLength + 1];            } else {                j = 1 + tagInputBuffA[i + locTagLength];            }            /*copy the tag's value to output buffer*/            if (((inputTagLength == 1) && (loctag[0] == tagInputTag[0])) || ((inputTagLength == 2) && (loctag[0] == tagInputTag[0]) && (loctag[1] == tagInputTag[1]))) {                ret++;                System.arraycopy(tagInputBuffA, i, tagOutputBuffATLV, k, j + locTagLength);                k = k + j + locTagLength;                tagOutputTotal = k;            }            /*move to the next tag*/            i = j + i + locTagLength;        }        return tagOutputTotal;    }    int apduErrTanslation(int apduRet) {        switch (apduRet) {            case 0x6700:                return ErrorCodeConstant.ERR_LC_LE;            case 0x6901:                return ErrorCodeConstant.ERR_INVALID_STATUS;            case 0x6981:                return ErrorCodeConstant.ERR_FILE_WRONG;            case 0x6982:                return ErrorCodeConstant.ERR_UNSAFE;            case 0x6983:                return ErrorCodeConstant.ERR_KEY_LOCK;            case 0x6984:                return ErrorCodeConstant.ERR_INVALID_RND;            case 0x6985:                return ErrorCodeConstant.ERR_INVALID_COND;            case 0x6986:            case 0x9401:            case 0x9402:            case 0x6B00:            case 0x6F00:            case 0x6A86:                return -apduRet;            case 0x6988:                return ErrorCodeConstant.ERR_WRONG_MAC;            case 0x6A80:                return ErrorCodeConstant.ERR_WRONG_PARA;            case 0x6A81:                return ErrorCodeConstant.ERR_NO_MF;            case 0x6A82:                return ErrorCodeConstant.ERR_NO_FILE;            case 0x6A83:                return ErrorCodeConstant.ERR_NO_RECORD;            case 0x6A88:                return ErrorCodeConstant.ERR_NO_KEY;            case 0x9403:                return ErrorCodeConstant.ERR_PSAM_TRANS;            case 0x6D00:            case 0x6E00:                return -apduRet;            case 0x9302:                return ErrorCodeConstant.ERR_INVALID_MAC;            case 0x9303:                return ErrorCodeConstant.ERR_CARD_LOCK;            case 0x9406:                return ErrorCodeConstant.ERR_NO_MAC;            //case 0x7614:            //	return ERR_NO_CARD;            case 0x6581:                return -apduRet;            default:                int hi = apduRet >> 8;                int low = apduRet;                switch (hi) {                    case 0x63:                        if (low > 0xC2) {                            return ErrorCodeConstant.ERR_EXT_VERIFY_2;                        } else if (low == 0xC2) {                            return ErrorCodeConstant.ERR_EXT_VERIFY_2;                        } else if (low == 0xC1) {                            return ErrorCodeConstant.ERR_EXT_VERIFY_1;                        } else {                            return ErrorCodeConstant.ERR_EXT_VERIFY_0;                        }                    default:                        return -apduRet;                }        }    }    public int ReadSSCard(int handle, String[] SICardData) {//读社保卡 （2代）        byte[] idcarddata = new byte[3000];        int idcarddatalen = 0;        int res = 0;        int len=0;        int sendLen = 0;        int usercardVer = 0;        char xbcode=3;        int[] pRevAPDULen = new int[1];        byte[] pSendAPDU = new byte[512];        byte[] pRecvRes = new byte[512];        byte[] pRecvRestemp = new byte[4];        byte[] pRecvRestemp1 = new byte[512];        byte[] pRecvResVersion ={0x00,0x00,0x00,0x00};        byte[] pRecvResVersion1 ={0x31,0x2E,0x30,0x30};        byte[] pRecvResVersion2 ={0x32,0x2E,0x30,0x30};        byte[] pRecvResVersion3 ={0x33,0x2E,0x30,0x30};        int tempnumber=0;        String kh;        String name;        String nameex;        String nation;        String xingbie;        String chsd;        String chsrq;        SetNad((byte) 0x12);        pSendAPDU = HexString.hexStringToByte("0012000000");//复位        sendLen = pSendAPDU.length;        res = HIDTransmit( pSendAPDU, sendLen, pRecvRes, pRevAPDULen);        tempnumber=0;        while((res==0x6FF2||res==0x6FF1)&&tempnumber<5){            tempnumber++;            res = HIDTransmit( pSendAPDU, sendLen, pRecvRes, pRevAPDULen);        }        if (res != 0x9000) {            return -res;        }        pSendAPDU = HexString.hexStringToByte("00A404000F7378312E73682EC9E7BBE1B1A3D5CF");//选择社保应用        sendLen = pSendAPDU.length;        res = HIDTransmit( pSendAPDU, sendLen, pRecvRes, pRevAPDULen);        tempnumber=0;        while((res==0x6FF2||res==0x6FF1)&&tempnumber<5){            tempnumber++;            res = HIDTransmit( pSendAPDU, sendLen, pRecvRes, pRevAPDULen);        }        if((res & 0xff00 )== 0x6100){            byte[] cmd = HexString.hexStringToByte("00C0000000");            cmd[4] = (byte)(res & 0x00ff);            res = HIDTransmit(cmd,5,pRecvRes,pRevAPDULen);            tempnumber=0;            while((res==0x6FF2||res==0x6FF1)&&tempnumber<5){                tempnumber++;                res = HIDTransmit( pSendAPDU, sendLen, pRecvRes, pRevAPDULen);            }        }        if (res != 0x9000) {            return -res;        }        pSendAPDU = HexString.hexStringToByte("00A4000002EF05");//选择社保应用        sendLen = pSendAPDU.length;        res = HIDTransmit( pSendAPDU, sendLen, pRecvRes, pRevAPDULen);        tempnumber=0;        while((res==0x6FF2||res==0x6FF1)&&tempnumber<5){            tempnumber++;            res = HIDTransmit( pSendAPDU, sendLen, pRecvRes, pRevAPDULen);        }        if (res == 0x6a82) {            pSendAPDU = HexString.hexStringToByte("00A4020002EF05");            sendLen = pSendAPDU.length;            res = HIDTransmit( pSendAPDU, sendLen, pRecvRes, pRevAPDULen);            tempnumber=0;            while((res==0x6FF2||res==0x6FF1)&&tempnumber<5){                tempnumber++;                res = HIDTransmit( pSendAPDU, sendLen, pRecvRes, pRevAPDULen);            }        }        if(res !=0x9000){            return -res;        }        pSendAPDU = HexString.hexStringToByte("00B2030406");//读规范版本        sendLen = pSendAPDU.length;        res = HIDTransmit( pSendAPDU, sendLen, pRecvRes, pRevAPDULen);        tempnumber=0;        while((res==0x6FF2||res==0x6FF1)&&tempnumber<5){            tempnumber++;            res = HIDTransmit( pSendAPDU, sendLen, pRecvRes, pRevAPDULen);        }        if (res != 0x9000) {            return -res;        }        System.arraycopy(pRecvRes, 2, pRecvRestemp, 0, 4);        if(Arrays.equals(pRecvRestemp,pRecvResVersion))//如果代码规范为空 代表为1.00版本的规范        {            System.arraycopy(pRecvResVersion1,0,pRecvRestemp,0,4);        }        if(Arrays.equals(pRecvRestemp,pRecvResVersion1))        {            usercardVer=1;        }else if(Arrays.equals(pRecvRestemp,pRecvResVersion2)) {            usercardVer=2;        }else if(Arrays.equals(pRecvRestemp,pRecvResVersion3)) {            usercardVer=3;        }        //gfbb        pSendAPDU = HexString.hexStringToByte("00b207040b");//读卡号        sendLen = pSendAPDU.length;        res = HIDTransmit( pSendAPDU, sendLen, pRecvRes, pRevAPDULen);        tempnumber=0;        while((res==0x6FF2||res==0x6FF1)&&tempnumber<5){            tempnumber++;            res = HIDTransmit( pSendAPDU, sendLen, pRecvRes, pRevAPDULen);        }        if((res&0xFF00)==0x6C00)        {            pSendAPDU[4]=(byte)(res&0x00FF);            sendLen = pSendAPDU.length;            res = HIDTransmit( pSendAPDU, sendLen, pRecvRes, pRevAPDULen);            tempnumber=0;            while((res==0x6FF2||res==0x6FF1)&&tempnumber<5){                tempnumber++;                res = HIDTransmit( pSendAPDU, sendLen, pRecvRes, pRevAPDULen);            }        }        if (res != 0x9000) {            return -res;        }        try {            String TmpStr = new String(pRecvRes);            SICardData[0] = TmpStr.substring(2, pRevAPDULen[0]);        } catch (Exception e) {            SICardData[0] = "";        }        pSendAPDU = HexString.hexStringToByte("00A4000002EF06");        sendLen = pSendAPDU.length;        res = HIDTransmit( pSendAPDU, sendLen, pRecvRes, pRevAPDULen);        tempnumber=0;        while((res==0x6FF2||res==0x6FF1)&&tempnumber<5){            tempnumber++;            res = HIDTransmit( pSendAPDU, sendLen, pRecvRes, pRevAPDULen);        }        if (res == 0x6A82) {            pSendAPDU = HexString.hexStringToByte("00A4020002EF06");//选择社保应用            sendLen = pSendAPDU.length;            res = HIDTransmit( pSendAPDU, sendLen, pRecvRes, pRevAPDULen);            tempnumber=0;            while((res==0x6FF2||res==0x6FF1)&&tempnumber<5){                tempnumber++;                res = HIDTransmit( pSendAPDU, sendLen, pRecvRes, pRevAPDULen);            }        }        if (res != 0x9000) {            return -res;        }        pSendAPDU = HexString.hexStringToByte("00B2010414");//读社会保障号码        sendLen = pSendAPDU.length;        res = HIDTransmit( pSendAPDU, sendLen, pRecvRes, pRevAPDULen);        tempnumber=0;        while((res==0x6FF2||res==0x6FF1)&&tempnumber<5){            tempnumber++;            res = HIDTransmit( pSendAPDU, sendLen, pRecvRes, pRevAPDULen);        }        if((res&0xFF00)==0x6C00)        {            pSendAPDU[4]=(byte)(res&0x00FF);            sendLen = pSendAPDU.length;            res = HIDTransmit( pSendAPDU, sendLen, pRecvRes, pRevAPDULen);            tempnumber=0;            while((res==0x6FF2||res==0x6FF1)&&tempnumber<5){                tempnumber++;                res = HIDTransmit( pSendAPDU, sendLen, pRecvRes, pRevAPDULen);            }        }        if (res != 0x9000) {            return -res;        }        try {            String TmpStr = new String(pRecvRes);            SICardData[1] = TmpStr.substring(2, pRevAPDULen[0]);        } catch (Exception e) {            SICardData[1] = "";        }        pSendAPDU = HexString.hexStringToByte("00B2020420");//姓名        sendLen = pSendAPDU.length;        res = HIDTransmit( pSendAPDU, sendLen, pRecvRes, pRevAPDULen);        tempnumber=0;        while((res==0x6FF2||res==0x6FF1)&&tempnumber<5){            tempnumber++;            res = HIDTransmit( pSendAPDU, sendLen, pRecvRes, pRevAPDULen);        }        if((res&0xFF00)==0x6C00)        {            pSendAPDU[4]=(byte)(res&0x00FF);            sendLen = pSendAPDU.length;            res = HIDTransmit( pSendAPDU, sendLen, pRecvRes, pRevAPDULen);            tempnumber=0;            while((res==0x6FF2||res==0x6FF1)&&tempnumber<5){                tempnumber++;                res = HIDTransmit( pSendAPDU, sendLen, pRecvRes, pRevAPDULen);            }        }        if (res != 0x9000) {            return -res;        }        //xm        try {            String tmpStr=bytesToHexString(pRecvRes,pRevAPDULen[0]);            SICardData[2] =GBK2Chinese(tmpStr.substring(4));        } catch (Exception e) {            SICardData[2] = "";        }        if(usercardVer==2||usercardVer==3){            pSendAPDU = HexString.hexStringToByte("00B2030420");//扩展姓名            sendLen = pSendAPDU.length;            res = HIDTransmit( pSendAPDU, sendLen, pRecvRes, pRevAPDULen);            tempnumber=0;            while((res==0x6FF2||res==0x6FF1)&&tempnumber<5){                tempnumber++;                res = HIDTransmit( pSendAPDU, sendLen, pRecvRes, pRevAPDULen);            }            if((res&0xFF00)==0x6C00)            {                pSendAPDU[4]=(byte)(res&0x00FF);                sendLen = pSendAPDU.length;                res = HIDTransmit( pSendAPDU, sendLen, pRecvRes, pRevAPDULen);                tempnumber=0;                while((res==0x6FF2||res==0x6FF1)&&tempnumber<5){                    tempnumber++;                    res = HIDTransmit( pSendAPDU, sendLen, pRecvRes, pRevAPDULen);                }            }            if (res != 0x9000) {//扩展姓名失败                return -res;            }        }        if(usercardVer==2||usercardVer==3){            xbcode=4;        }        pSendAPDU = HexString.hexStringToByte("00B2030403");//性别        pSendAPDU[2]=(byte)xbcode;        sendLen = pSendAPDU.length;        res = HIDTransmit( pSendAPDU, sendLen, pRecvRes, pRevAPDULen);        tempnumber=0;        while((res==0x6FF2||res==0x6FF1)&&tempnumber<5){            tempnumber++;            res = HIDTransmit( pSendAPDU, sendLen, pRecvRes, pRevAPDULen);        }        if((res&0xFF00)==0x6C00)        {            pSendAPDU[4]=(byte)(res&0x00FF);            sendLen = pSendAPDU.length;            res = HIDTransmit( pSendAPDU, sendLen, pRecvRes, pRevAPDULen);            tempnumber=0;            while((res==0x6FF2||res==0x6FF1)&&tempnumber<5){                tempnumber++;                res = HIDTransmit( pSendAPDU, sendLen, pRecvRes, pRevAPDULen);            }        }        if (res != 0x9000) {            return -res;        }        if(pRecvRes[2]=='1')        {            try {                String TmpStr = "男";                SICardData[3] = TmpStr;            } catch (Exception e) {                SICardData[3] = "";            }        }else{            try {                String TmpStr =  "女";                SICardData[3] = TmpStr;            } catch (Exception e) {                SICardData[3] = "";            }        }        pSendAPDU = HexString.hexStringToByte("00B2050403");//民族        pSendAPDU[2]=(byte)(xbcode+1);        sendLen = pSendAPDU.length;        res = HIDTransmit( pSendAPDU, sendLen, pRecvRes, pRevAPDULen);        tempnumber=0;        while((res==0x6FF2||res==0x6FF1)&&tempnumber<5){            tempnumber++;            res = HIDTransmit( pSendAPDU, sendLen, pRecvRes, pRevAPDULen);        }        if((res&0xFF00)==0x6C00)        {            pSendAPDU[4]=(byte)(res&0x00FF);            sendLen = pSendAPDU.length;            res = HIDTransmit( pSendAPDU, sendLen, pRecvRes, pRevAPDULen);            tempnumber=0;            while((res==0x6FF2||res==0x6FF1)&&tempnumber<5){                tempnumber++;                res = HIDTransmit( pSendAPDU, sendLen, pRecvRes, pRevAPDULen);            }        }        if (res != 0x9000) {            return -res;        }        nation=decodeNation(pRecvRes[2]);//获取民族        try {            SICardData[4] = nation;        } catch (Exception e) {            SICardData[4] = "";        }        pSendAPDU = HexString.hexStringToByte("00B206040C");//出生地        pSendAPDU[2]=(byte)(xbcode+2);        sendLen = pSendAPDU.length;        res = HIDTransmit( pSendAPDU, sendLen, pRecvRes, pRevAPDULen);        tempnumber=0;        while((res==0x6FF2||res==0x6FF1)&&tempnumber<5){            tempnumber++;            res = HIDTransmit( pSendAPDU, sendLen, pRecvRes, pRevAPDULen);        }        if((res&0xFF00)==0x6C00)        {            pSendAPDU[4]=(byte)(res&0x00FF);            sendLen = pSendAPDU.length;            res = HIDTransmit( pSendAPDU, sendLen, pRecvRes, pRevAPDULen);            tempnumber=0;            while((res==0x6FF2||res==0x6FF1)&&tempnumber<5){                tempnumber++;                res = HIDTransmit( pSendAPDU, sendLen, pRecvRes, pRevAPDULen);            }        }        if (res != 0x9000) {            return -res;        }        try {            String tmpStr=bytesToHexString(pRecvRes,pRevAPDULen[0]);            SICardData[5] = tmpStr.substring(4);        } catch (Exception e) {            SICardData[5] = "";        }        pSendAPDU = HexString.hexStringToByte("00B207040D");//读出生日期        pSendAPDU[2]=(byte)(xbcode+3);        sendLen = pSendAPDU.length;        res = HIDTransmit( pSendAPDU, sendLen, pRecvRes, pRevAPDULen);        tempnumber=0;        while((res==0x6FF2||res==0x6FF1)&&tempnumber<5){            tempnumber++;            res = HIDTransmit( pSendAPDU, sendLen, pRecvRes, pRevAPDULen);        }        if((res&0xFF00)==0x6C00)        {            pSendAPDU[4]=(byte)(res&0x00FF);            sendLen = pSendAPDU.length;            res = HIDTransmit( pSendAPDU, sendLen, pRecvRes, pRevAPDULen);            tempnumber=0;            while((res==0x6FF2||res==0x6FF1)&&tempnumber<5){                tempnumber++;                res = HIDTransmit( pSendAPDU, sendLen, pRecvRes, pRevAPDULen);            }        }        if (res != 0x9000) {            return -res;        }        try {            String tmpStr=bytesToHexString(pRecvRes,pRevAPDULen[0]);            SICardData[6] = tmpStr.substring(4);        } catch (Exception e) {            SICardData[6] = "";        }        return 0;    }    //读取身份证数据，返回数据长度，大于零代表成功    public int ReadIDCard(int handle, byte[] IDCardData) {        byte[] idcarddata = new byte[3000];        int idcarddatalen = 0;        int res = 0;        int sendLen = 0;        int[] pRevAPDULen = new int[1];        byte[] pSendAPDU = new byte[512];        byte[] pRecvRes = new byte[512];        SetNad((byte) 0x1B);        pSendAPDU = HexString.hexStringToByte("0012000000");        sendLen = pSendAPDU.length;        res = HIDTransmit(pSendAPDU, sendLen, pRecvRes, pRevAPDULen);        if (res != 0x9000) {            return -res;        }        pSendAPDU = HexString.hexStringToByte("AAAAAA9669000312FFEE");        sendLen = pSendAPDU.length;        res = HIDTransmit(pSendAPDU, sendLen, pRecvRes, pRevAPDULen);        if (res != 0x9000) {            return -res;        }        pSendAPDU = HexString.hexStringToByte("aaaaaa9669000461ff78e2");        sendLen = pSendAPDU.length;        res = HIDTransmit(pSendAPDU, sendLen, pRecvRes, pRevAPDULen);        if (res != 0x9000) {            return -res;        }        pSendAPDU = HexString.hexStringToByte("aaaaaa96690003200122");        sendLen = pSendAPDU.length;        res = HIDTransmit(pSendAPDU, sendLen, pRecvRes, pRevAPDULen);        if (res != 0x9000) {            return -res;        }        pSendAPDU = HexString.hexStringToByte("aaaaaa96690003200221");        sendLen = pSendAPDU.length;        res = HIDTransmit(pSendAPDU, sendLen, pRecvRes, pRevAPDULen);        if (res != 0x9000) {            return -res;        }        pSendAPDU = HexString.hexStringToByte("aaaaaa96690003300132");        sendLen = pSendAPDU.length;        res = HIDTransmit(pSendAPDU, sendLen, IDCardData, pRevAPDULen);        if (res != 0x9000) {            return -res;        }        return pRevAPDULen[0];    }    int AnalyzeIDData(Context context, byte[] IDCardData, int IDcardDatalen, String[] decodeInfo) {        byte[] idcardwz = new byte[256];        byte[] idcardxp = new byte[2000];        int idcardwzlen = 0;        int idcardxplen = 0;        if (IDCardData[7] != 0x00 || IDCardData[8] != 0x00 || IDCardData[9] != (byte) 0x90) {            return -1;        }        idcardwzlen = IDCardData[10] * 256 + IDCardData[11];        idcardxplen = IDCardData[12] * 256 + IDCardData[13];        for (int i = 0; i < 256; i++) {            idcardwz[i] = IDCardData[14 + i];        }        for (int i = 0; i < idcardxplen; i++) {            idcardxp[i] = IDCardData[14 + i + idcardwzlen];        }        try {            String TmpStr = new String(idcardwz, "UTF16-LE");            TmpStr = new String(TmpStr.getBytes("UTF-8"));            decodeInfo[0] = TmpStr.substring(0, 15);            decodeInfo[1] = TmpStr.substring(15, 16);            decodeInfo[2] = TmpStr.substring(16, 18);            decodeInfo[3] = TmpStr.substring(18, 26);            decodeInfo[4] = TmpStr.substring(26, 61);            decodeInfo[5] = TmpStr.substring(61, 79);            decodeInfo[6] = TmpStr.substring(79, 94);            decodeInfo[7] = TmpStr.substring(94, 102);            decodeInfo[8] = TmpStr.substring(102, 110);            decodeInfo[9] = TmpStr.substring(110, 128);            if (decodeInfo[1].equals("1")) {                decodeInfo[1] = "男";            } else {                decodeInfo[1] = "女";            }            int code = Integer.parseInt(decodeInfo[2].toString());            decodeInfo[2] = decodeNation(code);        } catch (Exception e) {            decodeInfo[2] = "";        }        //照片解析        try {            int ret = IDCReaderSDK.Init(context);            if (ret == 0) {                byte[] datawlt = new byte[1384];                byte[] byLicData = {(byte) 0x05, (byte) 0x00, (byte) 0x01, (byte) 0x00, (byte) 0x5B, (byte) 0x03, (byte) 0x33, (byte) 0x01, (byte) 0x5A, (byte) 0xB3, (byte) 0x1E, (byte) 0x00};                int t = IDCReaderSDK.unpack(IDCardData, byLicData);                if (t == 1) {                    return 0;// 照片解析成功                } else {                    return -6;// 照片解析失败                }            } else {                return -6;// 照片解析失败            }        } catch (Exception e) {            return -6;// 照片解析失败        }//        return 0;    }    public String decodeNation(int code) {        String nation;        switch (code) {            case 01:                nation = "汉";                break;            case 02:                nation = "蒙古";                break;            case 03:                nation = "回";                break;            case 04:                nation = "藏";                break;            case 05:                nation = "维吾";                break;            case 06:                nation = "苗";                break;            case 07:                nation = "彝";                break;            case 8:                nation = "壮";                break;            case 9:                nation = "布依";                break;            case 10:                nation = "朝鲜";                break;            case 11:                nation = "满";                break;            case 12:                nation = "侗族";                break;            case 13:                nation = "瑶";                break;            case 14:                nation = "白";                break;            case 15:                nation = "土家";                break;            case 16:                nation = "哈尼";                break;            case 17:                nation = "哈萨克";                break;            case 18:                nation = "傣";                break;            case 19:                nation = "黎";                break;            case 20:                nation = "傈僳";                break;            case 21:                nation = "佤";                break;            case 22:                nation = "畲";                break;            case 23:                nation = "高山";                break;            case 24:                nation = "拉祜";                break;            case 25:                nation = "水";                break;            case 26:                nation = "东乡";                break;            case 27:                nation = "纳西";                break;            case 28:                nation = "景颇";                break;            case 29:                nation = "柯尔克孜";                break;            case 30:                nation = "土";                break;            case 31:                nation = "达斡尔";                break;            case 32:                nation = "仫佬";                break;            case 33:                nation = "羌";                break;            case 34:                nation = "布朗";                break;            case 35:                nation = "撒拉";                break;            case 36:                nation = "毛南";                break;            case 37:                nation = "仡佬";                break;            case 38:                nation = "锡伯";                break;            case 39:                nation = "阿昌";                break;            case 40:                nation = "普米";                break;            case 41:                nation = "塔吉克";                break;            case 42:                nation = "怒";                break;            case 43:                nation = "乌孜别克";                break;            case 44:                nation = "俄罗斯";                break;            case 45:                nation = "鄂温克";                break;            case 46:                nation = "德昂";                break;            case 47:                nation = "保安";                break;            case 48:                nation = "裕固";                break;            case 49:                nation = "京";                break;            case 50:                nation = "塔塔尔";                break;            case 51:                nation = "独龙";                break;            case 52:                nation = "鄂伦春";                break;            case 53:                nation = "赫哲";                break;            case 54:                nation = "门巴";                break;            case 55:                nation = "珞巴";                break;            case 56:                nation = "基诺";                break;            case 97:                nation = "其他";                break;            case 98:                nation = "外国血统中国籍人士";                break;            default:                nation = "";                break;        }        return nation;    }}